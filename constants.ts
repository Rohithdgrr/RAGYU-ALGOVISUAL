import { Algorithm, AlgorithmCategory } from './types';

export const ALGORITHMS: Algorithm[] = [
  // --- Sorting ---
  { id: 'bubble-sort', name: 'Bubble Sort', category: AlgorithmCategory.SORTING, complexity: { time: 'O(n²)', space: 'O(1)' }, description: 'Repeatedly swaps adjacent elements if they are in the wrong order.' },
  { id: 'selection-sort', name: 'Selection Sort', category: AlgorithmCategory.SORTING, complexity: { time: 'O(n²)', space: 'O(1)' }, description: 'Finds the minimum element and moves it to the beginning.' },
  { id: 'insertion-sort', name: 'Insertion Sort', category: AlgorithmCategory.SORTING, complexity: { time: 'O(n²)', space: 'O(1)' }, description: 'Builds the final sorted array one item at a time.' },
  { id: 'merge-sort', name: 'Merge Sort', category: AlgorithmCategory.SORTING, complexity: { time: 'O(n log n)', space: 'O(n)' }, description: 'Divide and conquer algorithm that splits and merges subarrays.' },
  { id: 'quick-sort', name: 'Quick Sort', category: AlgorithmCategory.SORTING, complexity: { time: 'O(n log n)', space: 'O(log n)' }, description: 'Partitions array around a pivot and sorts segments recursively.' },
  { id: 'heap-sort', name: 'Heap Sort', category: AlgorithmCategory.SORTING, complexity: { time: 'O(n log n)', space: 'O(1)' }, description: 'Uses a binary heap data structure to sort elements.' },
  { id: 'counting-sort', name: 'Counting Sort', category: AlgorithmCategory.SORTING, complexity: { time: 'O(n+k)', space: 'O(k)' }, description: 'Counts occurrences of each unique element to sort integers.' },
  { id: 'radix-sort', name: 'Radix Sort', category: AlgorithmCategory.SORTING, complexity: { time: 'O(d(n+k))', space: 'O(n+k)' }, description: 'Sorts integers by processing individual digits.' },
  { id: 'shell-sort', name: 'Shell Sort', category: AlgorithmCategory.SORTING, complexity: { time: 'O(n log n)', space: 'O(1)' }, description: 'Generalized insertion sort with diminishing increment sequence.' },
  { id: 'bucket-sort', name: 'Bucket Sort', category: AlgorithmCategory.SORTING, complexity: { time: 'O(n+k)', space: 'O(n+k)' }, description: 'Distributes elements into buckets, sorts each bucket, then concatenates.' },

  // --- Searching ---
  { id: 'linear-search', name: 'Linear Search', category: AlgorithmCategory.SEARCHING, complexity: { time: 'O(n)', space: 'O(1)' }, description: 'Checks every element until the target is found.' },
  { id: 'binary-search', name: 'Binary Search', category: AlgorithmCategory.SEARCHING, complexity: { time: 'O(log n)', space: 'O(1)' }, description: 'Search in a sorted array by repeatedly dividing search interval in half.' },
  { id: 'jump-search', name: 'Jump Search', category: AlgorithmCategory.SEARCHING, complexity: { time: 'O(√n)', space: 'O(1)' }, description: 'Search in sorted array by jumping fixed steps ahead.' },
  { id: 'exponential-search', name: 'Exponential Search', category: AlgorithmCategory.SEARCHING, complexity: { time: 'O(log n)', space: 'O(1)' }, description: 'Search in infinite arrays by doubling range.' },
  { id: 'interpolation-search', name: 'Interpolation Search', category: AlgorithmCategory.SEARCHING, complexity: { time: 'O(log log n)', space: 'O(1)' }, description: 'Search in sorted array using interpolation formula.' },

  // --- Arrays ---
  { id: 'two-pointers', name: 'Two Pointers', category: AlgorithmCategory.ARRAYS, complexity: { time: 'O(n)', space: 'O(1)' }, description: 'Uses two pointers to solve array problems efficiently.' },
  { id: 'sliding-window', name: 'Sliding Window', category: AlgorithmCategory.ARRAYS, complexity: { time: 'O(n)', space: 'O(k)' }, description: 'Maintains a window of elements for subarray problems.' },
  { id: 'rotate-array', name: 'Rotate Array', category: AlgorithmCategory.ARRAYS, complexity: { time: 'O(n)', space: 'O(1)' }, description: 'Rotates array elements by k positions.' },
  { id: 'move-zeroes', name: 'Move Zeroes', category: AlgorithmCategory.ARRAYS, complexity: { time: 'O(n)', space: 'O(1)' }, description: 'Moves all zeros to the end while maintaining order.' },
  { id: 'merge-sorted-arrays', name: 'Merge Sorted Arrays', category: AlgorithmCategory.ARRAYS, complexity: { time: 'O(n+m)', space: 'O(1)' }, description: 'Merges two sorted arrays into one sorted array.' },
  { id: 'subarray-sum', name: 'Subarray Sum', category: AlgorithmCategory.ARRAYS, complexity: { time: 'O(n²)', space: 'O(1)' }, description: 'Finds subarray that sums to a target value.' },
  { id: 'find-duplicate', name: 'Find Duplicate', category: AlgorithmCategory.ARRAYS, complexity: { time: 'O(n)', space: 'O(1)' }, description: 'Finds duplicate number in array using Floyd\'s algorithm.' },
  { id: 'missing-number', name: 'Missing Number', category: AlgorithmCategory.ARRAYS, complexity: { time: 'O(n)', space: 'O(1)' }, description: 'Finds missing number in range using XOR or sum.' },
  { id: 'product-array', name: 'Product Except Self', category: AlgorithmCategory.ARRAYS, complexity: { time: 'O(n)', space: 'O(1)' }, description: 'Computes product of array except self without division.' },
  { id: 'max-subarray', name: 'Maximum Subarray', category: AlgorithmCategory.ARRAYS, complexity: { time: 'O(n)', space: 'O(1)' }, description: 'Finds contiguous subarray with maximum sum.' },
  { id: 'contains-duplicate', name: 'Contains Duplicate', category: AlgorithmCategory.ARRAYS, complexity: { time: 'O(n)', space: 'O(n)' }, description: 'Checks if array contains any duplicate elements.' },
  { id: 'single-number', name: 'Single Number', category: AlgorithmCategory.ARRAYS, complexity: { time: 'O(n)', space: 'O(1)' }, description: 'Finds the element that appears only once.' },
  { id: 'intersection', name: 'Intersection of Arrays', category: AlgorithmCategory.ARRAYS, complexity: { time: 'O(n+m)', space: 'O(min(n,m))' }, description: 'Finds intersection of two arrays.' },
  { id: 'majority-element', name: 'Majority Element', category: AlgorithmCategory.ARRAYS, complexity: { time: 'O(n)', space: 'O(1)' }, description: 'Finds element appearing more than n/2 times.' },
  { id: 'sort-colors', name: 'Sort Colors', category: AlgorithmCategory.ARRAYS, complexity: { time: 'O(n)', space: 'O(1)' }, description: 'Dutch national flag problem for 3 colors.' },
  { id: 'peak-element', name: 'Peak Element', category: AlgorithmCategory.ARRAYS, complexity: { time: 'O(log n)', space: 'O(1)' }, description: 'Finds a peak element in array using binary search.' },

  // --- Linked List ---
  { id: 'reverse-linked-list', name: 'Reverse Linked List', category: AlgorithmCategory.LINKED_LIST, complexity: { time: 'O(n)', space: 'O(1)' }, description: 'Reverses the direction of pointers in a linked list.' },
  { id: 'detect-cycle', name: 'Detect Cycle (Floyd’s)', category: AlgorithmCategory.LINKED_LIST, complexity: { time: 'O(n)', space: 'O(1)' }, description: 'Uses two pointers at different speeds to find loops.' },
  { id: 'find-middle', name: 'Find Middle', category: AlgorithmCategory.LINKED_LIST, complexity: { time: 'O(n)', space: 'O(1)' }, description: 'Uses tortoise and hare approach to find the center node.' },
  { id: 'merge-sorted-lists', name: 'Merge Sorted Lists', category: AlgorithmCategory.LINKED_LIST, complexity: { time: 'O(n+m)', space: 'O(1)' }, description: 'Merges two sorted linked lists into one.' },
  { id: 'palindrome-list', name: 'Palindrome List', category: AlgorithmCategory.LINKED_LIST, complexity: { time: 'O(n)', space: 'O(1)' }, description: 'Checks if a linked list is a palindrome.' },
  { id: 'remove-duplicates', name: 'Remove Duplicates', category: AlgorithmCategory.LINKED_LIST, complexity: { time: 'O(n)', space: 'O(1)' }, description: 'Removes duplicate nodes from sorted linked list.' },
  { id: 'remove-nth-from-end', name: 'Remove Nth From End', category: AlgorithmCategory.LINKED_LIST, complexity: { time: 'O(n)', space: 'O(1)' }, description: 'Removes nth node from the end of list.' },
  { id: 'add-two-numbers', name: 'Add Two Numbers', category: AlgorithmCategory.LINKED_LIST, complexity: { time: 'O(max(m,n))', space: 'O(max(m,n))' }, description: 'Adds two numbers represented by linked lists.' },
  { id: 'swap-nodes-pairs', name: 'Swap Nodes in Pairs', category: AlgorithmCategory.LINKED_LIST, complexity: { time: 'O(n)', space: 'O(1)' }, description: 'Swaps every two adjacent nodes in linked list.' },
  { id: 'rotate-list', name: 'Rotate List', category: AlgorithmCategory.LINKED_LIST, complexity: { time: 'O(n)', space: 'O(1)' }, description: 'Rotates linked list to the right by k places.' },

  // --- Graphs ---
  { id: 'bfs', name: 'Breadth First Search (BFS)', category: AlgorithmCategory.GRAPHS, complexity: { time: 'O(V+E)', space: 'O(V)' }, description: 'Explores nodes layer by layer from a starting point.' },
  { id: 'dfs', name: 'Depth First Search (DFS)', category: AlgorithmCategory.GRAPHS, complexity: { time: 'O(V+E)', space: 'O(V)' }, description: 'Explores as far as possible along each branch before backtracking.' },
  { id: 'dijkstra', name: "Dijkstra's Algorithm", category: AlgorithmCategory.GRAPHS, complexity: { time: 'O(E log V)', space: 'O(V)' }, description: 'Finds the shortest paths from a source to all nodes in a weighted graph.' },
  { id: 'bellman-ford', name: 'Bellman-Ford', category: AlgorithmCategory.GRAPHS, complexity: { time: 'O(VE)', space: 'O(V)' }, description: 'Computes shortest paths, even with negative edge weights.' },
  { id: 'floyd-warshall', name: 'Floyd-Warshall', category: AlgorithmCategory.GRAPHS, complexity: { time: 'O(V³)', space: 'O(V²)' }, description: 'Finds shortest paths between all pairs of vertices.' },
  { id: 'prim', name: "Prim's Algorithm", category: AlgorithmCategory.GRAPHS, complexity: { time: 'O(E log V)', space: 'O(V)' }, description: 'Finds a minimum spanning tree for a weighted undirected graph.' },
  { id: 'kruskal', name: "Kruskal's Algorithm", category: AlgorithmCategory.GRAPHS, complexity: { time: 'O(E log E)', space: 'O(V)' }, description: 'Finds a minimum spanning tree using a greedy approach.' },
  { id: 'topological-sort', name: 'Topological Sort', category: AlgorithmCategory.GRAPHS, complexity: { time: 'O(V+E)', space: 'O(V)' }, description: 'Linear ordering of vertices for directed acyclic graphs.' },
  { id: 'a-star', name: 'A* Search', category: AlgorithmCategory.GRAPHS, complexity: { time: 'O(E)', space: 'O(V)' }, description: 'Pathfinding algorithm using heuristics for efficient search.' },
  { id: 'union-find', name: 'Union Find', category: AlgorithmCategory.GRAPHS, complexity: { time: 'O(α(n))', space: 'O(V)' }, description: 'Disjoint set data structure for cycle detection.' },
  { id: 'bipartite-check', name: 'Bipartite Check', category: AlgorithmCategory.GRAPHS, complexity: { time: 'O(V+E)', space: 'O(V)' }, description: 'Checks if graph can be colored with two colors.' },
  { id: 'graph-cycle', name: 'Detect Cycle', category: AlgorithmCategory.GRAPHS, complexity: { time: 'O(V+E)', space: 'O(V)' }, description: 'Detects cycles in undirected or directed graphs.' },
  { id: 'connected-components', name: 'Connected Components', category: AlgorithmCategory.GRAPHS, complexity: { time: 'O(V+E)', space: 'O(V)' }, description: 'Finds all connected components in a graph.' },
  { id: 'shortest-path-bfs', name: 'Shortest Path BFS', category: AlgorithmCategory.GRAPHS, complexity: { time: 'O(V+E)', space: 'O(V)' }, description: 'Finds shortest path in unweighted graph using BFS.' },
  { id: 'mst-boruvka', name: "Boruvka's Algorithm", category: AlgorithmCategory.GRAPHS, complexity: { time: 'O(E log V)', space: 'O(V)' }, description: 'Finds minimum spanning tree using edge contraction.' },
  { id: 'articulation-points', name: 'Articulation Points', category: AlgorithmCategory.GRAPHS, complexity: { time: 'O(V+E)', space: 'O(V)' }, description: 'Finds critical vertices whose removal disconnects graph.' },
  { id: 'bridges', name: 'Bridges', category: AlgorithmCategory.GRAPHS, complexity: { time: 'O(V+E)', space: 'O(V)' }, description: 'Finds critical edges whose removal disconnects graph.' },
  { id: 'eulerian-path', name: 'Eulerian Path', category: AlgorithmCategory.GRAPHS, complexity: { time: 'O(E)', space: 'O(V)' }, description: 'Finds path using every edge exactly once.' },
  { id: 'hamiltonian-cycle', name: 'Hamiltonian Cycle', category: AlgorithmCategory.GRAPHS, complexity: { time: 'O(n!)', space: 'O(n)' }, description: 'Finds cycle visiting each vertex exactly once.' },
  { id: 'graph-coloring', name: 'Graph Coloring', category: AlgorithmCategory.GRAPHS, complexity: { time: 'O(n^m)', space: 'O(n)' }, description: 'Colors graph with minimum colors.' },

  // --- Trees ---
  { id: 'tree-preorder', name: 'Pre-order Traversal', category: AlgorithmCategory.TREES, complexity: { time: 'O(n)', space: 'O(h)' }, description: 'Visit root, then left subtree, then right subtree.' },
  { id: 'tree-inorder', name: 'In-order Traversal', category: AlgorithmCategory.TREES, complexity: { time: 'O(n)', space: 'O(h)' }, description: 'Visit left subtree, root, then right subtree.' },
  { id: 'tree-postorder', name: 'Post-order Traversal', category: AlgorithmCategory.TREES, complexity: { time: 'O(n)', space: 'O(h)' }, description: 'Visit left subtree, right subtree, then root.' },
  { id: 'tree-levelorder', name: 'Level-order Traversal', category: AlgorithmCategory.TREES, complexity: { time: 'O(n)', space: 'O(w)' }, description: 'Visit nodes level by level using a queue.' },
  { id: 'tree-insert', name: 'BST Insert', category: AlgorithmCategory.TREES, complexity: { time: 'O(h)', space: 'O(1)' }, description: 'Inserts a node into a binary search tree.' },
  { id: 'tree-delete', name: 'BST Delete', category: AlgorithmCategory.TREES, complexity: { time: 'O(h)', space: 'O(1)' }, description: 'Deletes a node from a binary search tree.' },
  { id: 'tree-rotation', name: 'Tree Rotation', category: AlgorithmCategory.TREES, complexity: { time: 'O(1)', space: 'O(1)' }, description: 'Rotates nodes to balance the tree structure.' },
  { id: 'tree-search', name: 'BST Search', category: AlgorithmCategory.TREES, complexity: { time: 'O(h)', space: 'O(1)' }, description: 'Searches for a value in binary search tree.' },
  { id: 'tree-height', name: 'Tree Height', category: AlgorithmCategory.TREES, complexity: { time: 'O(n)', space: 'O(h)' }, description: 'Calculates the height of a binary tree.' },
  { id: 'tree-diameter', name: 'Tree Diameter', category: AlgorithmCategory.TREES, complexity: { time: 'O(n)', space: 'O(h)' }, description: 'Finds the longest path between any two nodes.' },
  { id: 'tree-path-sum', name: 'Path Sum', category: AlgorithmCategory.TREES, complexity: { time: 'O(n)', space: 'O(h)' }, description: 'Checks if root-to-leaf path sum equals target.' },
  { id: 'tree-lowest-common', name: 'Lowest Common Ancestor', category: AlgorithmCategory.TREES, complexity: { time: 'O(n)', space: 'O(h)' }, description: 'Finds LCA of two nodes in binary tree.' },
  { id: 'tree-symmetric', name: 'Symmetric Tree', category: AlgorithmCategory.TREES, complexity: { time: 'O(n)', space: 'O(h)' }, description: 'Checks if tree is mirror of itself.' },
  { id: 'tree-flatten', name: 'Flatten to List', category: AlgorithmCategory.TREES, complexity: { time: 'O(n)', space: 'O(n)' }, description: 'Flattens binary tree to linked list.' },
  { id: 'tree-validate', name: 'Validate BST', category: AlgorithmCategory.TREES, complexity: { time: 'O(n)', space: 'O(h)' }, description: 'Validates if tree is a valid binary search tree.' },
  { id: 'tree-zigzag', name: 'Zigzag Level Order', category: AlgorithmCategory.TREES, complexity: { time: 'O(n)', space: 'O(n)' }, description: 'Level order traversal with alternating direction.' },
  { id: 'tree-maximum', name: 'Maximum Path Sum', category: AlgorithmCategory.TREES, complexity: { time: 'O(n)', space: 'O(h)' }, description: 'Finds maximum path sum in binary tree.' },
  { id: 'tree-count', name: 'Count Nodes', category: AlgorithmCategory.TREES, complexity: { time: 'O(n)', space: 'O(h)' }, description: 'Counts total nodes in binary tree.' },
  { id: 'tree-same', name: 'Same Tree', category: AlgorithmCategory.TREES, complexity: { time: 'O(n)', space: 'O(h)' }, description: 'Checks if two trees are identical.' },
  { id: 'tree-subtree', name: 'Subtree Check', category: AlgorithmCategory.TREES, complexity: { time: 'O(n*m)', space: 'O(h)' }, description: 'Checks if one tree is subtree of another.' },
  { id: 'tree-serialize', name: 'Serialize Tree', category: AlgorithmCategory.TREES, complexity: { time: 'O(n)', space: 'O(n)' }, description: 'Serializes binary tree to string.' },
  { id: 'tree-deserialize', name: 'Deserialize Tree', category: AlgorithmCategory.TREES, complexity: { time: 'O(n)', space: 'O(n)' }, description: 'Deserializes string to binary tree.' },
  { id: 'tree-mirror', name: 'Mirror Tree', category: AlgorithmCategory.TREES, complexity: { time: 'O(n)', space: 'O(h)' }, description: 'Creates mirror image of binary tree.' },

  // --- Dynamic Programming ---
  { id: 'knapsack', name: '0/1 Knapsack', category: AlgorithmCategory.DYNAMIC_PROGRAMMING, complexity: { time: 'O(nW)', space: 'O(nW)' }, description: 'Maximizes total value of items without exceeding weight capacity.' },
  { id: 'lcs', name: 'Longest Common Subsequence', category: AlgorithmCategory.DYNAMIC_PROGRAMMING, complexity: { time: 'O(nm)', space: 'O(nm)' }, description: 'Finds the longest subsequence common to two sequences.' },
  { id: 'edit-distance', name: 'Edit Distance', category: AlgorithmCategory.DYNAMIC_PROGRAMMING, complexity: { time: 'O(nm)', space: 'O(nm)' }, description: 'Minimum number of operations to transform one string into another.' },
  { id: 'rod-cutting', name: 'Rod Cutting', category: AlgorithmCategory.DYNAMIC_PROGRAMMING, complexity: { time: 'O(n²)', space: 'O(n)' }, description: 'Maximizes profit by cutting rods optimally.' },
  { id: 'palindrome-partitioning', name: 'Palindrome Partitioning', category: AlgorithmCategory.DYNAMIC_PROGRAMMING, complexity: { time: 'O(n²)', space: 'O(n²)' }, description: 'Partitions string into minimum palindromic substrings.' },
  { id: 'longest-palindromic-subsequence', name: 'Longest Palindromic Subsequence', category: AlgorithmCategory.DYNAMIC_PROGRAMMING, complexity: { time: 'O(n²)', space: 'O(n²)' }, description: 'Finds longest subsequence that reads the same forwards and backwards.' },
  { id: 'max-subarray-sum', name: 'Max Subarray Sum', category: AlgorithmCategory.DYNAMIC_PROGRAMMING, complexity: { time: 'O(n)', space: 'O(1)' }, description: 'Finds contiguous subarray with maximum sum (Kadane\'s).' },
  { id: 'unique-paths', name: 'Unique Paths', category: AlgorithmCategory.DYNAMIC_PROGRAMMING, complexity: { time: 'O(mn)', space: 'O(mn)' }, description: 'Counts paths from top-left to bottom-right in grid.' },
  { id: 'coin-change', name: 'Coin Change', category: AlgorithmCategory.DYNAMIC_PROGRAMMING, complexity: { time: 'O(nW)', space: 'O(W)' }, description: 'Finds minimum coins to make a target amount.' },
  { id: 'subset-sum', name: 'Subset Sum', category: AlgorithmCategory.DYNAMIC_PROGRAMMING, complexity: { time: 'O(nW)', space: 'O(W)' }, description: 'Checks if subset sums to target value.' },
  { id: 'climbing-stairs', name: 'Climbing Stairs', category: AlgorithmCategory.DYNAMIC_PROGRAMMING, complexity: { time: 'O(n)', space: 'O(1)' }, description: 'Ways to reach top taking 1 or 2 steps.' },
  { id: 'house-robber', name: 'House Robber', category: AlgorithmCategory.DYNAMIC_PROGRAMMING, complexity: { time: 'O(n)', space: 'O(1)' }, description: 'Maximize robbed money without adjacent houses.' },
  { id: 'longest-increasing', name: 'Longest Increasing', category: AlgorithmCategory.DYNAMIC_PROGRAMMING, complexity: { time: 'O(n²)', space: 'O(n)' }, description: 'Finds longest increasing subsequence.' },
  { id: 'matrix-chain', name: 'Matrix Chain', category: AlgorithmCategory.DYNAMIC_PROGRAMMING, complexity: { time: 'O(n³)', space: 'O(n²)' }, description: 'Optimal matrix multiplication order.' },
  { id: 'word-break', name: 'Word Break', category: AlgorithmCategory.DYNAMIC_PROGRAMMING, complexity: { time: 'O(n²)', space: 'O(n)' }, description: 'Checks if string can be segmented.' },
  { id: 'partition-equal', name: 'Partition Equal', category: AlgorithmCategory.DYNAMIC_PROGRAMMING, complexity: { time: 'O(nW)', space: 'O(W)' }, description: 'Partitions array into equal sum subsets.' },
  { id: 'decode-ways', name: 'Decode Ways', category: AlgorithmCategory.DYNAMIC_PROGRAMMING, complexity: { time: 'O(n)', space: 'O(1)' }, description: 'Ways to decode numeric string.' },
  { id: 'minimum-path', name: 'Minimum Path', category: AlgorithmCategory.DYNAMIC_PROGRAMMING, complexity: { time: 'O(mn)', space: 'O(mn)' }, description: 'Minimum path sum in grid.' },
  { id: 'burst-balloons', name: 'Burst Balloons', category: AlgorithmCategory.DYNAMIC_PROGRAMMING, complexity: { time: 'O(n³)', space: 'O(n²)' }, description: 'Maximum coins by bursting balloons.' },
  { id: 'integer-break', name: 'Integer Break', category: AlgorithmCategory.DYNAMIC_PROGRAMMING, complexity: { time: 'O(n)', space: 'O(n)' }, description: 'Maximum product of integers summing to n.' },

  // --- Backtracking ---
  { id: 'n-queens', name: 'N-Queens Solver', category: AlgorithmCategory.BACKTRACKING, complexity: { time: 'O(N!)', space: 'O(N)' }, description: 'Places N queens on an NxN board so none can attack another.' },
  { id: 'sudoku-solver', name: 'Sudoku Solver', category: AlgorithmCategory.BACKTRACKING, complexity: { time: 'O(9^(n*n))', space: 'O(n²)' }, description: 'Solves Sudoku puzzles using backtracking.' },
  { id: 'subset-sum', name: 'Subset Sum', category: AlgorithmCategory.BACKTRACKING, complexity: { time: 'O(2^n)', space: 'O(n)' }, description: 'Finds subset that sums to a target value.' },
  { id: 'hamiltonian-path', name: 'Hamiltonian Path', category: AlgorithmCategory.BACKTRACKING, complexity: { time: 'O(n!)', space: 'O(n)' }, description: 'Finds path visiting each vertex exactly once.' },
  { id: 'word-search', name: 'Word Search', category: AlgorithmCategory.BACKTRACKING, complexity: { time: 'O(n*m*8^L)', space: 'O(L)' }, description: 'Finds words in a grid using backtracking.' },
  
  // --- Mathematics ---
  { id: 'sieve', name: 'Sieve of Eratosthenes', category: AlgorithmCategory.MATHEMATICS, complexity: { time: 'O(n log log n)', space: 'O(n)' }, description: 'Finds all prime numbers up to a given limit.' },
  { id: 'gcd', name: 'GCD (Euclidean)', category: AlgorithmCategory.MATHEMATICS, complexity: { time: 'O(log(min(a,b)))', space: 'O(1)' }, description: 'Finds the greatest common divisor of two numbers.' },
  { id: 'lcm', name: 'LCM', category: AlgorithmCategory.MATHEMATICS, complexity: { time: 'O(log(min(a,b)))', space: 'O(1)' }, description: 'Finds the least common multiple of two numbers.' },
  { id: 'prime-factorization', name: 'Prime Factorization', category: AlgorithmCategory.MATHEMATICS, complexity: { time: 'O(√n)', space: 'O(log n)' }, description: 'Breaks down a number into its prime factors.' },
  { id: 'fibonacci', name: 'Fibonacci Sequence', category: AlgorithmCategory.MATHEMATICS, complexity: { time: 'O(n)', space: 'O(1)' }, description: 'Generates the Fibonacci sequence iteratively.' },
  { id: 'factorial', name: 'Factorial', category: AlgorithmCategory.MATHEMATICS, complexity: { time: 'O(n)', space: 'O(1)' }, description: 'Calculates the factorial of a number.' },
  { id: 'pascal-triangle', name: 'Pascal Triangle', category: AlgorithmCategory.MATHEMATICS, complexity: { time: 'O(n²)', space: 'O(n²)' }, description: 'Generates Pascal triangle with binomial coefficients.' },
  { id: 'binary-exponentiation', name: 'Binary Exponentiation', category: AlgorithmCategory.MATHEMATICS, complexity: { time: 'O(log n)', space: 'O(1)' }, description: 'Fast exponentiation using binary representation.' },
  { id: 'extended-euclidean', name: 'Extended Euclidean', category: AlgorithmCategory.MATHEMATICS, complexity: { time: 'O(log(min(a,b)))', space: 'O(1)' }, description: 'Finds GCD and Bézout coefficients.' },
  { id: 'modular-exp', name: 'Modular Exponentiation', category: AlgorithmCategory.MATHEMATICS, complexity: { time: 'O(log n)', space: 'O(1)' }, description: 'Calculates (base^exp) % mod efficiently.' },
  { id: 'power-set', name: 'Power Set', category: AlgorithmCategory.MATHEMATICS, complexity: { time: 'O(2^n)', space: 'O(2^n)' }, description: 'Generates all possible subsets of a set.' },
  { id: 'catalan-numbers', name: 'Catalan Numbers', category: AlgorithmCategory.MATHEMATICS, complexity: { time: 'O(n)', space: 'O(1)' }, description: 'Computes Catalan numbers using dynamic programming.' },
  { id: 'matrix-multiplication', name: 'Matrix Multiplication', category: AlgorithmCategory.MATHEMATICS, complexity: { time: 'O(n³)', space: 'O(n²)' }, description: 'Multiplies two matrices using standard algorithm.' },
  { id: 'matrix-transpose', name: 'Matrix Transpose', category: AlgorithmCategory.MATHEMATICS, complexity: { time: 'O(n²)', space: 'O(1)' }, description: 'Transposes a matrix by swapping rows and columns.' },
  { id: 'euler-totient', name: 'Euler Totient', category: AlgorithmCategory.MATHEMATICS, complexity: { time: 'O(√n)', space: 'O(1)' }, description: 'Counts numbers coprime to a given number.' },
  { id: 'chinese-remainder', name: 'Chinese Remainder', category: AlgorithmCategory.MATHEMATICS, complexity: { time: 'O(n²)', space: 'O(n)' }, description: 'Solves system of simultaneous congruences.' },
  { id: 'modular-inverse', name: 'Modular Inverse', category: AlgorithmCategory.MATHEMATICS, complexity: { time: 'O(log n)', space: 'O(1)' }, description: 'Finds modular inverse using extended Euclidean.' },
  { id: 'discrete-log', name: 'Discrete Logarithm', category: AlgorithmCategory.MATHEMATICS, complexity: { time: 'O(√n)', space: 'O(1)' }, description: 'Solves discrete logarithm problem.' },
  { id: 'miller-rabin', name: 'Miller-Rabin Primality', category: AlgorithmCategory.MATHEMATICS, complexity: { time: 'O(k log³ n)', space: 'O(1)' }, description: 'Probabilistic primality test.' },
  { id: 'sieve-segmented', name: 'Segmented Sieve', category: AlgorithmCategory.MATHEMATICS, complexity: { time: 'O(n log log n)', space: 'O(√n)' }, description: 'Finds primes in large range using segmented sieve.' },
  { id: 'fast-fourier', name: 'Fast Fourier Transform', category: AlgorithmCategory.MATHEMATICS, complexity: { time: 'O(n log n)', space: 'O(n)' }, description: 'Efficient algorithm for polynomial multiplication.' },
  { id: 'stirling-numbers', name: 'Stirling Numbers', category: AlgorithmCategory.MATHEMATICS, complexity: { time: 'O(nk)', space: 'O(nk)' }, description: 'Counts permutations with k cycles.' },
  { id: 'bernoulli-numbers', name: 'Bernoulli Numbers', category: AlgorithmCategory.MATHEMATICS, complexity: { time: 'O(n²)', space: 'O(n)' }, description: 'Computes Bernoulli numbers using formula.' },
  { id: 'permutations', name: 'Permutations', category: AlgorithmCategory.MATHEMATICS, complexity: { time: 'O(n!)', space: 'O(n!)' }, description: 'Generates all permutations of a set.' },
  { id: 'combinations', name: 'Combinations', category: AlgorithmCategory.MATHEMATICS, complexity: { time: 'O(n choose k)', space: 'O(k)' }, description: 'Computes binomial coefficients.' },
  
  // --- Strings ---
  { id: 'kmp', name: 'KMP Pattern Search', category: AlgorithmCategory.STRINGS, complexity: { time: 'O(n+m)', space: 'O(m)' }, description: 'Efficient pattern matching using a prefix function.' },
  { id: 'rabin-karp', name: 'Rabin-Karp', category: AlgorithmCategory.STRINGS, complexity: { time: 'O(n+m)', space: 'O(1)' }, description: 'Pattern matching using rolling hash functions.' },
  { id: 'boyer-moore', name: 'Boyer-Moore', category: AlgorithmCategory.STRINGS, complexity: { time: 'O(n/m)', space: 'O(1)' }, description: 'Efficient pattern matching with bad character heuristic.' },
  { id: 'z-algorithm', name: 'Z-Algorithm', category: AlgorithmCategory.STRINGS, complexity: { time: 'O(n)', space: 'O(n)' }, description: 'Finds all occurrences of a pattern in a string.' },
  { id: 'string-reverse', name: 'String Reverse', category: AlgorithmCategory.STRINGS, complexity: { time: 'O(n)', space: 'O(1)' }, description: 'Reverses a string in-place using two pointers.' },
  { id: 'string-rotation', name: 'String Rotation', category: AlgorithmCategory.STRINGS, complexity: { time: 'O(n)', space: 'O(1)' }, description: 'Checks if one string is rotation of another.' },
  { id: 'longest-prefix', name: 'Longest Prefix', category: AlgorithmCategory.STRINGS, complexity: { time: 'O(n)', space: 'O(n)' }, description: 'Finds longest prefix which is also suffix.' },
  { id: 'anagram-check', name: 'Anagram Check', category: AlgorithmCategory.STRINGS, complexity: { time: 'O(n)', space: 'O(1)' }, description: 'Checks if two strings are anagrams.' },
  { id: 'substring-search', name: 'Substring Search', category: AlgorithmCategory.STRINGS, complexity: { time: 'O(nm)', space: 'O(1)' }, description: 'Naive substring search algorithm.' },
  { id: 'longest-palindrome', name: 'Longest Palindrome', category: AlgorithmCategory.STRINGS, complexity: { time: 'O(n²)', space: 'O(1)' }, description: 'Finds longest palindromic substring.' },
  { id: 'string-compression', name: 'String Compression', category: AlgorithmCategory.STRINGS, complexity: { time: 'O(n)', space: 'O(n)' }, description: 'Compresses string using character counts.' },
  { id: 'valid-parentheses', name: 'Valid Parentheses', category: AlgorithmCategory.STRINGS, complexity: { time: 'O(n)', space: 'O(n)' }, description: 'Validates bracket matching in string.' },
  { id: 'longest-substring', name: 'Longest Substring', category: AlgorithmCategory.STRINGS, complexity: { time: 'O(n)', space: 'O(min(m,n))' }, description: 'Longest substring without repeating characters.' },
  { id: 'min-window', name: 'Minimum Window', category: AlgorithmCategory.STRINGS, complexity: { time: 'O(n+m)', space: 'O(1)' }, description: 'Minimum window substring containing all characters.' },
  { id: 'word-break', name: 'Word Break', category: AlgorithmCategory.STRINGS, complexity: { time: 'O(n²)', space: 'O(n)' }, description: 'Checks if string can be segmented into dictionary words.' },
  { id: 'group-anagrams', name: 'Group Anagrams', category: AlgorithmCategory.STRINGS, complexity: { time: 'O(n*k*log k)', space: 'O(n*k)' }, description: 'Groups strings that are anagrams of each other.' },
  { id: 'str-str', name: 'Str Str', category: AlgorithmCategory.STRINGS, complexity: { time: 'O(n*m)', space: 'O(1)' }, description: 'Returns index of first occurrence of needle in haystack.' },
  { id: 'multiply-strings', name: 'Multiply Strings', category: AlgorithmCategory.STRINGS, complexity: { time: 'O(n*m)', space: 'O(n+m)' }, description: 'Multiplies two numbers represented as strings.' },
  { id: 'count-and-say', name: 'Count and Say', category: AlgorithmCategory.STRINGS, complexity: { time: 'O(2^n)', space: 'O(2^n)' }, description: 'Generates count and say sequence.' },

  // --- Hash Table ---
  { id: 'hash-insert', name: 'Hash Insert', category: AlgorithmCategory.HASH_TABLE, complexity: { time: 'O(1) avg', space: 'O(n)' }, description: 'Inserts values into hash table using modulo hashing.' },
  { id: 'hash-search', name: 'Hash Search', category: AlgorithmCategory.HASH_TABLE, complexity: { time: 'O(1) avg', space: 'O(1)' }, description: 'Searches for values in hash table by hash key.' },
  { id: 'hash-delete', name: 'Hash Delete', category: AlgorithmCategory.HASH_TABLE, complexity: { time: 'O(1) avg', space: 'O(1)' }, description: 'Deletes values from hash table.' },
  { id: 'hash-collision', name: 'Hash Collision', category: AlgorithmCategory.HASH_TABLE, complexity: { time: 'O(n) worst', space: 'O(n)' }, description: 'Handles collisions using linear probing.' },
  { id: 'hash-rehash', name: 'Hash Rehash', category: AlgorithmCategory.HASH_TABLE, complexity: { time: 'O(n)', space: 'O(n)' }, description: 'Resizes hash table when load factor is high.' },
  { id: 'hash-chaining', name: 'Hash Chaining', category: AlgorithmCategory.HASH_TABLE, complexity: { time: 'O(1) avg', space: 'O(n)' }, description: 'Handles collisions using linked list chains.' },
  { id: 'hash-double', name: 'Double Hashing', category: AlgorithmCategory.HASH_TABLE, complexity: { time: 'O(1) avg', space: 'O(n)' }, description: 'Uses two hash functions for collision resolution.' },
  { id: 'hash-open', name: 'Open Addressing', category: AlgorithmCategory.HASH_TABLE, complexity: { time: 'O(1) avg', space: 'O(n)' }, description: 'Stores elements directly in the hash table array.' },
  { id: 'hash-quadratic', name: 'Quadratic Probing', category: AlgorithmCategory.HASH_TABLE, complexity: { time: 'O(1) avg', space: 'O(n)' }, description: 'Uses quadratic function for collision resolution.' },
  { id: 'hash-universal', name: 'Universal Hashing', category: AlgorithmCategory.HASH_TABLE, complexity: { time: 'O(1) avg', space: 'O(n)' }, description: 'Random hash function to minimize collisions.' },
  { id: 'hash-consistent', name: 'Consistent Hashing', category: AlgorithmCategory.HASH_TABLE, complexity: { time: 'O(log n)', space: 'O(n)' }, description: 'Distributed caching with minimal rehashing.' },
  { id: 'hash-bloom', name: 'Bloom Filter', category: AlgorithmCategory.HASH_TABLE, complexity: { time: 'O(k)', space: 'O(m)' }, description: 'Probabilistic data structure for membership testing.' },
  { id: 'hash-cuckoo', name: 'Cuckoo Hashing', category: AlgorithmCategory.HASH_TABLE, complexity: { time: 'O(1) avg', space: 'O(n)' }, description: 'Uses two hash tables with worst case O(1) lookup.' },
  { id: 'hash-robin', name: 'Robin Hood Hashing', category: AlgorithmCategory.HASH_TABLE, complexity: { time: 'O(1) avg', space: 'O(n)' }, description: 'Minimizes variance in probe sequence length.' },
  { id: 'hash-hopscotch', name: 'Hopscotch Hashing', category: AlgorithmCategory.HASH_TABLE, complexity: { time: 'O(1) avg', space: 'O(n)' }, description: 'Neighborhood-based collision resolution.' },

  // --- Heap ---
  { id: 'max-heap-insert', name: 'Max Heap Insert', category: AlgorithmCategory.HEAP, complexity: { time: 'O(log n)', space: 'O(1)' }, description: 'Inserts element into max heap with heapify up.' },
  { id: 'max-heap-extract', name: 'Max Heap Extract', category: AlgorithmCategory.HEAP, complexity: { time: 'O(log n)', space: 'O(1)' }, description: 'Extracts maximum element from max heap.' },
  { id: 'min-heap-insert', name: 'Min Heap Insert', category: AlgorithmCategory.HEAP, complexity: { time: 'O(log n)', space: 'O(1)' }, description: 'Inserts element into min heap with heapify up.' },
  { id: 'min-heap-extract', name: 'Min Heap Extract', category: AlgorithmCategory.HEAP, complexity: { time: 'O(log n)', space: 'O(1)' }, description: 'Extracts minimum element from min heap.' },
  { id: 'heap-build', name: 'Heap Build', category: AlgorithmCategory.HEAP, complexity: { time: 'O(n)', space: 'O(1)' }, description: 'Builds a heap from an array in linear time.' },

  // --- Geometry ---
  { id: 'graham-scan', name: 'Graham Scan', category: AlgorithmCategory.GEOMETRY, complexity: { time: 'O(n log n)', space: 'O(n)' }, description: 'Computes convex hull using polar angle sorting.' },
  { id: 'jarvis-march', name: 'Jarvis March', category: AlgorithmCategory.GEOMETRY, complexity: { time: 'O(nh)', space: 'O(h)' }, description: 'Gift wrapping algorithm for convex hull.' },
  { id: 'closest-pair', name: 'Closest Pair', category: AlgorithmCategory.GEOMETRY, complexity: { time: 'O(n²)', space: 'O(1)' }, description: 'Finds the pair of points with minimum distance.' },
  { id: 'line-intersection', name: 'Line Intersection', category: AlgorithmCategory.GEOMETRY, complexity: { time: 'O(n²)', space: 'O(1)' }, description: 'Finds all intersection points among lines.' },
  { id: 'convex-hull-monotone', name: 'Convex Hull (Monotone)', category: AlgorithmCategory.GEOMETRY, complexity: { time: 'O(n log n)', space: 'O(n)' }, description: 'Computes convex hull using monotone chain algorithm.' },

  // --- Greedy ---
  { id: 'activity-selection', name: 'Activity Selection', category: AlgorithmCategory.GREEDY, complexity: { time: 'O(n log n)', space: 'O(1)' }, description: 'Selects maximum non-overlapping activities.' },
  { id: 'huffman-coding', name: 'Huffman Coding', category: AlgorithmCategory.GREEDY, complexity: { time: 'O(n log n)', space: 'O(n)' }, description: 'Optimal prefix coding for data compression.' },
  { id: 'fractional-knapsack', name: 'Fractional Knapsack', category: AlgorithmCategory.GREEDY, complexity: { time: 'O(n log n)', space: 'O(1)' }, description: 'Maximizes value with fractional items allowed.' },
  { id: 'job-sequencing', name: 'Job Sequencing', category: AlgorithmCategory.GREEDY, complexity: { time: 'O(n²)', space: 'O(n)' }, description: 'Schedules jobs to maximize profit with deadlines.' },
  { id: 'coin-change-greedy', name: 'Coin Change (Greedy)', category: AlgorithmCategory.GREEDY, complexity: { time: 'O(n log n)', space: 'O(1)' }, description: 'Finds minimum coins for canonical coin systems.' },
];

export const COLORS = {
  DEFAULT: '#f1f5f9',
  ACTIVE: '#6366f1',
  COMPARING: '#f59e0b',
  SORTED: '#10b981',
  TARGET: '#ef4444',
  HIGHLIGHT: '#8b5cf6',
  PATH: '#3b82f6',
  HULL: '#ec4899',
  VISITED: '#a78bfa',
  CURRENT: '#f472b6',
  SWAPPING: '#fbbf24',
  PIVOT: '#818cf8',
  LEFT: '#34d399',
  RIGHT: '#fb923c',
  MERGED: '#a5b4fc',
  SELECTED: '#fda4af',
  MIN: '#4ade80',
  MAX: '#f87171',
  PROCESSING: '#c084fc',
  COMPLETED: '#2dd4bf',
  ERROR: '#fb7185',
  WARNING: '#fcd34d',
  INFO: '#60a5fa',
  SUCCESS: '#34d399',
  NEUTRAL: '#94a3b8',
  PRIMARY: '#6366f1',
  SECONDARY: '#8b5cf6',
  ACCENT: '#ec4899',
  BACKGROUND: '#ffffff',
  TEXT: '#1e293b',
  TEXT_LIGHT: '#64748b',
  BORDER: '#e2e8f0',
  SHADOW: 'rgba(0, 0, 0, 0.1)',
  GLOW: 'rgba(99, 102, 241, 0.3)'
};